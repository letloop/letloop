(define reverse (xeno reverse))
(define print (xeno (lambda args (write args) (newline) (flush-output-port))))

(define pk (xeno (lambda args
                   (display ";;;; ")
                   (write args)
                   (newline)
                   (car (reverse args)))))

(define quote
  (vau args _ (car args)))

(define let-binding
  (vau (bindings . body) env
    (define mylambda (eval (list* lambda (map car bindings) body) env))
    (define objects (map (lambda (x) (car (cdr x))) bindings))
    (eval (list* mylambda objects) env)))


(define let-loop
  (vau (name bindings . body) env
    (define proc (eval (list* 'lambda
                              (map car bindings)
                              body) env))
    (define env*
      (make-environment env
                        (list (cons name
                                    proc))))

    (eval (list* name
                 (map (lambda (x) (car (cdr x)))
                      bindings))
          env*)))

(define pair? (xeno pair?))

(define let
  (vau (some . rest) env
    (if (pair? some)
        (apply let-binding env some rest)
        (apply let-loop env some rest))))

(define + (xeno +))
(define - (xeno -))
(define zero? (xeno zero?))

(define when
  (vau (test . body) env
      (eval (list if test
                   (list* sequence body)
                   #f)
            env)))

(define ~check-let
  (lambda ()
    (let ((abc 42))
      (let loop ((abc abc))
        (when (not (zero? abc))
          (pk abc)
          (loop (- abc 1)))))))

(define and
  (vau (a . args) env
    (if (not (eval a env))
        #f
        (if (null? args)
            #t
            (apply and env args)))))

(define string-upper (xeno string-upcase))
(define string-lower (xeno string-downcase))

(define or
  (vau (a . args) env
    (if (eval a env)
        #t
        (if (null? args)
            #f
            (apply or env args)))))

(define cond
  (vau (clause . clauses) env
    (define predicate (car clause))
    (define production (pk 'production (cdr clause)))

    (pk 'predicate predicate)
    (if (eq? predicate 'else)
        (eval (list* sequence production) env)
        (if (pk (eval predicate env))
            (eval (list* sequence production) env)
            (if (null? clauses)
                (error 'cond "no condition is met")
                (apply cond env clauses))))))

(define match
  (vau (exp clause . clauses) env
    (define obj (eval exp env))

    (define aux
      (vau (clause . clauses)
        (define pattern (car clause))
        (define production (car (cdr clause)))

        (define env* (match-exec pattern exp))

        (if env*
            (eval production
                  (environment-cons* env env*))
            (if (null? clauses)
                (error 'match "no match :(")
                (apply match env obj clauses)))))

    (apply aux clause clauses)))
