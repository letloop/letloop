(import (chezscheme))
(import (letloop termbox2))


(define termbox-print
  (lambda (line string color)
    (dg 'ooops line string color)
    (let loop ((index 0)
               (chars (string->list string)))
      (unless (null? chars)
        (tb-change-cell index line (char->integer (car chars)) color TB-DEFAULT)
        (loop (fx+ index 1) (cdr chars))))))

(define continue? #t)

(define %error (open-file-output-port "out.log"
                                      (file-options no-fail)
                                      (buffer-mode line)
                                      (native-transcoder)))

(define (dg . rest)
  (write rest %error) (newline %error)
  (car (reverse rest)))

(define amawal
  (list
   (list "ğŸš°" "eau" "water" "aman" "â´°âµâ´°âµŠ")
   (list "ğŸšª" "porte" "door" "tabburt" "âµœâ´°âµ€âµ€â´»âµ”âµœ")
   (list "ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦" "famille" "family" "tawacult" "âµœâ´°âµ¡â´°âµ›â´»âµâµœ")
   (list "â›°ï¸" "montagne" "moutain" "adrar" "â´°â´·âµ”â´°âµ”")
   (list "ğŸ¥¾" "chaussure" "boot" "asbbadd" "â´°âµ™â´»â´±â´±â´°â´¹")
   (list "ğŸ”¥" "feu" "fire" "times" "âµœâµ‰âµâ´»âµ™")
   (list "ğŸ–" "main" "hand" "afus" "â´°â´¼âµ“âµ™")
   (list "ğŸ‘¨" "homme" "man" "argaz" "â´°âµ”â´³â´°âµ£")
   (list "ğŸ‘‰" "la-bas" "there" "dihin" "â´·âµ‰âµ€âµ‰âµ")
   (list "ğŸŒƒ" "nuit" "night" "idd" "âµ‰â´¹")
   (list "ğŸ•Š" "paix" "peace" "lehna" "âµâ´°âµ€âµŠâ´°")
   (list "â˜®ï¸" "paix" "peace" "lehna" "âµâ´°âµ€âµŠâ´°")
   (list "ğŸŒ§" "pluie" "rain" "lahwa" "âµâ´°âµ€âµ¡â´°")
   (list "ğŸ¥œ" "cacahuete" "peanut" "kawkaw" "â´½â´°âµ¡â´½â´°âµ¡")
   (list "ğŸ±" "chat" "cat" "amchiche" "â´°âµâµ›âµ‰âµ›")
   (list "ğŸ•‘" "deux" "two" "sin" "âµ™âµ‰âµ")
   (list "ğŸ¥µ" "chaleur" "hot" "lhamou" "âµâµƒâ´°âµâµ“")
   (list "ğŸ‘ƒ" "nez" "nose" "anzaren" "â´°âµâµ£â´°âµ”â´»âµ")
   (list "ğŸ‹" "citron" "lemon" "lqares" "âµâµ‡â´°âµ•âµ“âµ™")
   (list "ğŸŒ" "escargot" "snail" "ararouss" "â´°âµ„â´°âµ•âµ“âµ™")
   (list "ğŸ˜„" "rire" "laugh" "tadssa" "âµœâ´°â´¹âµšâ´°")
   ))


(define tifinagh
  (lambda ()
    (map (lambda (x) (list (string->list (car x)) (cadr x)))
         (list (list "ya" "â´°")
               (list "yab" "â´±")
               (list "yach" "âµ›")
               (list "yad" "â´·")
               (list "yadd" "â´¹")
               (list "yey" "â´»")
               (list "yaf" "â´¼")
               (list "yag" "â´³")
               (list "yah" "âµ€")
               (list "yi" "âµ‰")
               (list "yaj" "âµŠ")
               (list "yak" "â´½")
               (list "yal" "âµ")
               (list "yam" "âµ")
               (list "yan" "âµ")
               (list "yaa" "âµ„")
               (list "yahh" "âµƒ")
               (list "yaq" "âµ‡")
               (list "yar" "âµ”")
               (list "yarr" "âµ•")
               (list "yas" "âµ™")
               (list "yass" "âµš")
               (list "yat" "âµœ")
               (list "yatt" "âµŸ")
               (list "you" "âµ“")
               (list "yagh" "âµ–")
               (list "yaw" "âµ¡")
               (list "yakh" "âµ…")
               (list "yay" "âµ¢")
               (list "yaz" "âµ£")
               (list "yazz" "âµ¥")))))

(define choice
  (lambda (objects)
    (list-ref objects (random (length objects)))))

(define welcome "Welcome to termbox typer! Type Ctrl + Q to quit.")
(define message " Type any key...")
(define message2 "")
(define tifi (choice (tifinagh)))
(define entry '())

(define new-question
  (lambda (key)
    (set! message2 "")
    (set! entry '())
    (set! tifi (choice (tifinagh)))
    (set! message (format #f "The letter is `~a` it is typed `~a`. Please type it?" (cadr tifi) (car tifi)))
    (set! callback ask)))

(define ask
  (lambda (key)
    (set! message2 "")
    (cond
     ((and (key? key) (or (eq? (key-key key) 'backspace)
                          (eq? (key-key key) 'backspace2)))
      (set! entry
            (if (null? entry)
                '()
                (cdr entry))))
     ((and (key? key) (eq? (key-key key) #\space))
       (if (equal? (reverse entry) (car tifi))
           (begin
             (set! message "You win. Type any key to continue...")
             (set! callback new-question))
           (set! message2 "Oops... That is wrong, use backspace to delete previous key")))
      (else (set! entry (cons (key-key key) entry))))))
        

(define callback new-question)
    
(define (main)
  (tb-init)
  ;; (tb-select-output-mode TB-INIT)
  (let loop ((count 0))
    (tb-clear)
    (tb-hide-cursor)
    (termbox-print 1 welcome TB-YELLOW)
    (termbox-print 3 message TB-GREEN)
    (termbox-print 5 message2 TB-BLUE)
    (unless (null? entry)
      (termbox-print 6 (format #f "entry> ~a" (reverse entry)) TB-BLUE))
    (tb-present)
    (let ((event (tb-poll-event)))
      (if (and (key? event)
               (equal? (key-key event) #\q)
               (key-ctrl? event))
          (set! continue? #f)
          (begin
            (callback event)
            (loop (fx+ count 1)))))))
        
(tb-shutdown)
(main)
